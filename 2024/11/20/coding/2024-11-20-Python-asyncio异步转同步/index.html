<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Lil b">





<title>Python-asyncio异步转同步 | Lil b</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Lil B&#39;s apartment</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Lil B&#39;s apartment</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Python-asyncio异步转同步</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Lil b</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 20, 2024&nbsp;&nbsp;5:04:32</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/debug/">debug</a>
                            
                                <a href="/categories/debug/coding/">coding</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>在Python编程中，异步编程（Asynchronous Programming）和同步编程（Synchronous Programming）是两种常见的编程范式。理解如何在这两者之间转换，对于在实际项目中有效利用异步特性以及与现有同步代码集成至关重要。本文将详细介绍如何将Python中的异步代码转换为同步代码，涵盖<code>run_coroutine_threadsafe</code>等方法，以及异步生成器（<code>async_gen</code>）的转换。</p>
<h2 id="一、异步与同步编程概述"><a href="#一、异步与同步编程概述" class="headerlink" title="一、异步与同步编程概述"></a>一、异步与同步编程概述</h2><h3 id="1-1-同步编程"><a href="#1-1-同步编程" class="headerlink" title="1.1 同步编程"></a>1.1 同步编程</h3><ul>
<li><strong>执行模型</strong>：同步编程按照指令的顺序逐步执行，每个操作必须等待前一个操作完成后才开始。</li>
<li><strong>优点</strong>：直观、简单，易于理解和调试。</li>
<li><strong>缺点</strong>：在处理I&#x2F;O密集型任务时，可能导致性能瓶颈，因为程序会等待I&#x2F;O操作完成。</li>
</ul>
<h3 id="1-2-异步编程"><a href="#1-2-异步编程" class="headerlink" title="1.2 异步编程"></a>1.2 异步编程</h3><ul>
<li><strong>执行模型</strong>：异步编程允许任务在等待I&#x2F;O操作时挂起，释放线程去执行其他任务，完成后再恢复执行。</li>
<li><strong>优点</strong>：更高的性能，特别是在I&#x2F;O密集型应用中，因为可以更有效地利用资源。</li>
<li><strong>缺点</strong>：编程模型复杂，调试困难度较高。</li>
</ul>
<p>Python通过<code>asyncio</code>库为异步编程提供了强大的支持。</p>
<h2 id="二、Python异步编程基础"><a href="#二、Python异步编程基础" class="headerlink" title="二、Python异步编程基础"></a>二、Python异步编程基础</h2><h3 id="2-0-参考链接"><a href="#2-0-参考链接" class="headerlink" title="2.0 参考链接"></a>2.0 参考链接</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mrlonely2018/p/15998293.html" title="发布于 2022-03-12 20:25">学习python异步编程asyncio之协程和任务</a><br><a target="_blank" rel="noopener" href="https://github.com/hsz1273327/TutorialForPython/blob/master/%E8%AF%AD%E6%B3%95%E7%AF%87/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%8D%8F%E7%A8%8B.ipynb">阻塞异步与协程.ipynb</a></p>
<h3 id="2-1-asyncio概述"><a href="#2-1-asyncio概述" class="headerlink" title="2.1 asyncio概述"></a>2.1 <code>asyncio</code>概述</h3><p><code>asyncio</code>是Python标准库中的一个库，旨在编写并发代码，特别是处理I&#x2F;O密集型和高层次结构化网络代码。它基于协程（coroutines）和事件循环（event loop）的概念。</p>
<h3 id="2-2-基本概念"><a href="#2-2-基本概念" class="headerlink" title="2.2 基本概念"></a>2.2 基本概念</h3><ul>
<li><strong>协程（Coroutine）</strong>：特殊的生成器，支持异步操作的函数，使用<code>async def</code>定义。</li>
<li><strong>事件循环（Event Loop）</strong>：协调和调度协程执行的核心机制。</li>
<li><strong>任务（Task）</strong>：包装协程的对象，用于追踪协程的执行状态。</li>
</ul>
<h3 id="2-3-简单示例"><a href="#2-3-简单示例" class="headerlink" title="2.3 简单示例"></a>2.3 简单示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(say_hello())</span><br></pre></td></tr></table></figure>

<h2 id="三、异步转同步"><a href="#三、异步转同步" class="headerlink" title="三、异步转同步"></a>三、异步转同步</h2><p>在实际开发中，可能需要将异步代码转换为同步执行，特别是在与现有同步代码集成时。以下是几种常用的方法。</p>
<h3 id="3-0-参考链接"><a href="#3-0-参考链接" class="headerlink" title="3.0 参考链接"></a>3.0 参考链接</h3><p><a target="_blank" rel="noopener" href="https://github.com/rotationalio/pyensign/blob/c745da6dbb6a3999dbedb39ce4d3524bac56f4c0/pyensign/sync.py#L8">一份其他库里异步转同步的案例</a></p>
<h3 id="3-1-使用-asyncio-run"><a href="#3-1-使用-asyncio-run" class="headerlink" title="3.1 使用 asyncio.run"></a>3.1 使用 <code>asyncio.run</code></h3><p><code>asyncio.run</code> 是一种简单的方法，用于运行一个<strong>顶层</strong>的异步函数，并等待其完成。这适用于将异步代码作为脚本顶层入口执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步调用</span></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li><code>asyncio.run</code> 会创建并管理一个新的事件循环。</li>
<li>只能在主线程中调用，且不能在已有事件循环的环境中使用（例如，在Jupyter Notebook中可能会报错）。</li>
</ul>
<h3 id="3-2-使用事件循环的-run-until-complete"><a href="#3-2-使用事件循环的-run-until-complete" class="headerlink" title="3.2 使用事件循环的 run_until_complete"></a>3.2 使用事件循环的 <code>run_until_complete</code></h3><p>适用于需要更细粒度控制事件循环的场景。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 运行直到完成</span></span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li>在旧版本的Python（3.6及以下）中更常用。</li>
<li>在Python 3.7及以上，推荐使用<code>asyncio.run</code>。</li>
<li>可能需要手动管理事件循环的关闭。</li>
<li>若当前线程已存在事件循环（非运行状态），推荐使用本方法。</li>
</ul>
<h3 id="3-3-在现有同步线程中运行异步协程：run-coroutine-threadsafe"><a href="#3-3-在现有同步线程中运行异步协程：run-coroutine-threadsafe" class="headerlink" title="3.3 在现有同步线程中运行异步协程：run_coroutine_threadsafe"></a>3.3 在现有同步线程中运行异步协程：<code>run_coroutine_threadsafe</code></h3><p><code>run_coroutine_threadsafe</code> 是 <code>asyncio</code> 提供的方法，用于在已有事件循环的线程中，将协程提交给事件循环执行，并返回一个<code>concurrent.futures.Future</code>实例，可以用于等待协程的结果。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>将异步代码嵌入到多线程或多进程的同步代码中。</li>
<li>在GUI应用（如Tkinter、PyQt）中调用异步代码，同时保持界面响应。</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_task</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_async_in_sync</span>(<span class="params">x, y</span>):</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> loop.is_running():</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;Event loop is not running&quot;</span>)</span><br><span class="line">    future = asyncio.run_coroutine_threadsafe(async_task(x, y), loop)</span><br><span class="line">    <span class="keyword">return</span> future.result()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主线程中启动事件循环</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_event_loop</span>(<span class="params">loop</span>):</span><br><span class="line">    asyncio.set_event_loop(loop)</span><br><span class="line">    loop.run_forever()</span><br><span class="line"></span><br><span class="line">new_loop = asyncio.new_event_loop()</span><br><span class="line">t = threading.Thread(target=start_event_loop, args=(new_loop,), daemon=<span class="literal">True</span>)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在不同的线程中调用异步代码</span></span><br><span class="line">result = run_async_in_sync(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭事件循环</span></span><br><span class="line">new_loop.call_soon_threadsafe(new_loop.stop)</span><br><span class="line">t.join()</span><br><span class="line">new_loop.close() <span class="comment"># 这句不写貌似也可以，毕竟在单独的线程里，关不关都不妨碍主线程</span></span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ol>
<li>创建一个新的事件循环，并在单独的线程中运行它。</li>
<li>使用<code>asyncio.run_coroutine_threadsafe</code>将异步协程提交给事件循环执行。</li>
<li>使用<code>future.result()</code>等待并获取协程的结果。</li>
</ol>
<p><strong>注意事项</strong>：</p>
<ul>
<li>确保事件循环在单独的线程中持续运行，避免阻塞主线程。</li>
<li><strong>需要适当管理事件循环的启动和关闭</strong>，防止资源泄漏。<ul>
<li>这是一个比较难处理的问题，尤其在异步生成器转换时，下文会细说</li>
</ul>
</li>
</ul>
<h3 id="3-4-在现有事件循环中运行协程：nest-asyncio"><a href="#3-4-在现有事件循环中运行协程：nest-asyncio" class="headerlink" title="3.4 在现有事件循环中运行协程：nest_asyncio"></a>3.4 在现有事件循环中运行协程：<code>nest_asyncio</code></h3><blockquote>
<p>实践最好用这个</p>
</blockquote>
<p>有时在已有事件循环（如Jupyter Notebook）中需要运行协程，可以使用第三方库<code>nest_asyncio</code>来嵌套事件循环。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install nest_asyncio</span><br></pre></td></tr></table></figure>

<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line"></span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步调用</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li><code>nest_asyncio</code> 允许在已运行的事件循环中嵌套执行协程，适用于特殊的环境（例如web服务器、GUI或jupyternotebook等）。</li>
<li>不是所有场景下都适用，需谨慎使用。</li>
</ul>
<h2 id="四、异步生成器-async-gen-转换为同步"><a href="#四、异步生成器-async-gen-转换为同步" class="headerlink" title="四、异步生成器 (async_gen) 转换为同步"></a>四、异步生成器 (<code>async_gen</code>) 转换为同步</h2><p>异步生成器允许以异步的方式逐步产生数据。将异步生成器转换为同步代码，通常需要同步地迭代异步生成器。</p>
<h3 id="4-0-参考链接"><a href="#4-0-参考链接" class="headerlink" title="4.0 参考链接"></a>4.0 参考链接</h3><p><a target="_blank" rel="noopener" href="https://github.com/hikariatama/hikka-pyro/blob/f6e15767a4944ccb2acf04e21b9b046ff1fcf471/hikkapyro/sync.py#L36">一份他人实现方案</a><br><a target="_blank" rel="noopener" href="https://github.com/ydb-platform/ydb/blob/5b45c7497248b94d579ecaf8c43cdb997e1e66c0/contrib/python/grpcio/py3/grpc/_cython/_cygrpc/aio/common.pyx.pxi#L125">不知道是啥语言的神秘疑似伪代码但可以使用</a></p>
<h3 id="4-1-异步生成器示例"><a href="#4-1-异步生成器示例" class="headerlink" title="4.1 异步生成器示例"></a>4.1 异步生成器示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_gen</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

<h3 id="4-2-同步迭代异步生成器"><a href="#4-2-同步迭代异步生成器" class="headerlink" title="4.2 同步迭代异步生成器"></a>4.2 同步迭代异步生成器</h3><p>要在同步代码中迭代异步生成器，可以采用以下方法：</p>
<h4 id="方法一：使用事件循环和-anext"><a href="#方法一：使用事件循环和-anext" class="headerlink" title="方法一：使用事件循环和 __anext__"></a>方法一：使用事件循环和 <code>__anext__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_gen</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">async_gen_to_sync</span>(<span class="params">agen</span>):</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            next_coroutine = agen.__anext__()</span><br><span class="line">            value = loop.run_until_complete(next_coroutine)</span><br><span class="line">            <span class="keyword">yield</span> value</span><br><span class="line">        <span class="keyword">except</span> StopAsyncIteration:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> async_gen_to_sync(async_gen()):</span><br><span class="line">	<span class="built_in">print</span>(v)</span><br></pre></td></tr></table></figure>

<p>还有一种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sync_iter_async_gen</span>(<span class="params">agen</span>):</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">iter</span>(<span class="keyword">lambda</span>: loop.run_until_complete(agen.__anext__()), <span class="literal">None</span>):</span><br><span class="line">		<span class="keyword">yield</span> value</span><br><span class="line">	<span class="keyword">except</span> StopAsyncIteration:</span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>容易发现，二者实质上是等价的。</p>
<p><strong>注意事项</strong>：</p>
<ul>
<li>此方法会在每次迭代时阻塞等待协程完成。</li>
<li>需要事件循环处于非运行状态，否则会引发错误。</li>
</ul>
<h4 id="方法二：使用-run-coroutine-threadsafe-在独立线程中运行"><a href="#方法二：使用-run-coroutine-threadsafe-在独立线程中运行" class="headerlink" title="方法二：使用 run_coroutine_threadsafe 在独立线程中运行"></a>方法二：使用 <code>run_coroutine_threadsafe</code> 在独立线程中运行</h4><p>这个要详细说一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_gen</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">async_gen_to_sync</span>(<span class="params">agen</span>):</span><br><span class="line">	loop = asyncio.new_event_loop()</span><br><span class="line">	t = threading.Thread(target=loop.run_forever)</span><br><span class="line">	t.start()</span><br><span class="line">	asyncio.set_event_loop(loop)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">iter</span>(<span class="keyword">lambda</span>: asyncio.run_coroutine_threadsafe(agen.__anext__(), loop).result(), <span class="literal">None</span>):</span><br><span class="line">			<span class="keyword">yield</span> value</span><br><span class="line">	<span class="keyword">except</span> StopAsyncIteration:</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="keyword">finally</span>:</span><br><span class="line">		loop.call_soon_threadsafe(loop.stop)</span><br><span class="line">		t.join()</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li>在独立的线程中启动事件循环，并运行异步生成器的消费协程。</li>
<li>主线程和事件循环线程互不干扰。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>不会阻塞主线程。</li>
<li>适用于需要并行处理的场景。</li>
</ul>
<p>隐藏问题：</p>
<ul>
<li>敏感的朋友很容易注意到，如果外部调用手动或意外中止，那么这个生成器无法获知这一点，依旧在自己单独线程里的<code>event_loop</code>中等待下一轮<code>yield</code>，也就是说只有手动<code>gen.close()</code>（等于在<code>try-except</code>语法中触发一个<code>GeneratorExit</code>错误，使函数运行到<code>finally</code>）或<code>stream finished</code>（整个生成器全部调用完，触发<code>StopAsyncIteration</code>）才能安全关掉<code>event_loop</code>。</li>
<li>这个感觉设计上没有更好的办法可以解决了，只能说用户自己用的时候多注意吧</li>
</ul>
<h4 id="方法三：收集所有生成的数据"><a href="#方法三：收集所有生成的数据" class="headerlink" title="方法三：收集所有生成的数据"></a>方法三：收集所有生成的数据</h4><p>如果异步生成器的数据量较小，可以将其全部收集到一个列表中，然后在同步代码中使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_gen</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">collect_async_gen</span>():</span><br><span class="line">    <span class="keyword">return</span> [item <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> async_gen()]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sync_collect</span>():</span><br><span class="line">    <span class="keyword">return</span> asyncio.run(collect_async_gen())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">results = sync_collect()</span><br><span class="line"><span class="built_in">print</span>(results)</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li>适用于数据量较小的生成器，避免大量数据占用内存。</li>
<li>无法逐步处理数据，需等待所有数据生成完成。</li>
</ul>
<h2 id="五、注意事项与最佳实践"><a href="#五、注意事项与最佳实践" class="headerlink" title="五、注意事项与最佳实践"></a>五、注意事项与最佳实践</h2><ol>
<li><p><strong>事件循环的管理</strong>：</p>
<ul>
<li>确保事件循环的创建、运行和关闭正确管理，避免资源泄漏或阻塞。</li>
<li>避免在同一个线程中重复创建事件循环。</li>
</ul>
</li>
<li><p><strong>线程安全</strong>：</p>
<ul>
<li><code>run_coroutine_threadsafe</code> 是线程安全的，但需要确保事件循环在另一个线程中运行。</li>
<li>避免在事件循环运行时阻塞事件循环线程。</li>
</ul>
</li>
<li><p><strong>异常处理</strong>：</p>
<ul>
<li>异步转同步时，需要适当捕获和处理异常，避免程序崩溃。</li>
<li>例如，使用<code>future.result()</code> 时，可能会引发协程中的异常。</li>
</ul>
</li>
<li><p><strong>性能考虑</strong>：</p>
<ul>
<li>将异步代码转换为同步代码可能会带来性能损失，尤其是在高频调用的场景。</li>
<li>尽量在需要时进行转换，避免频繁的上下文切换。</li>
</ul>
</li>
<li><p><strong>代码维护</strong>：</p>
<ul>
<li>保持异步与同步代码的清晰分离，避免混淆。</li>
<li>使用明确的接口和抽象层来管理异步与同步的交互。</li>
</ul>
</li>
</ol>
<h2 id="中插：一些额外的设计思考"><a href="#中插：一些额外的设计思考" class="headerlink" title="中插：一些额外的设计思考"></a>中插：一些额外的设计思考</h2><p>第五章中提到“保持异步与同步代码清晰分离，避免混淆”，这一点的确很重要，而异步转同步的操作本身即是违背了这一点的，这让人不禁想，一个良好的架构应当是如此混用的吗？</p>
<p>尤其是<code>run_coroutine_threadsafe</code>方法的使用场景，它几乎是为“异步调同步调异步”这样一个诡异的场景设计的，这是一个有必要的场景吗？用同步方法桥接两个异步方法？？</p>
<p>实际上，copy一份一模一样的同步方法，然后在其前面加个<code>async</code>，不就可以直接在该方法里<code>await</code>需要的异步方法了吗（即异步调异步调异步）？</p>
<p>我能想到的唯一有一定必要的场景就是“异步调同步…(同步*n)…调异步”，那么在不想为了一份async而copy+rewrite整条链路的情况下，确实需要使用<code>run_coroutine_threadsafe</code>，但这应当也是一个临时的处理方式，最健康的还是异步同步分离，最多进行一次转换。</p>
<p>当然<code>run_coroutine_threadsafe</code>其实也还好，当场转同步当场<code>loop.stop</code>还是挺安全的，只是切换上下文会有性能损失；十分不优雅的目前看只有类似生成器这种无法当场阻塞完的情况……</p>
<h2 id="六、完整示例"><a href="#六、完整示例" class="headerlink" title="六、完整示例"></a>六、完整示例</h2><p>以下是一个综合示例，展示了如何在同步代码中调用异步函数、处理异步生成器，以及使用<code>run_coroutine_threadsafe</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义异步任务</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义异步生成器</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_gen</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在独立线程中运行事件循环</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_event_loop</span>(<span class="params">loop</span>):</span><br><span class="line">    asyncio.set_event_loop(loop)</span><br><span class="line">    loop.run_forever()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并启动事件循环线程</span></span><br><span class="line">new_loop = asyncio.new_event_loop()</span><br><span class="line">t = threading.Thread(target=start_event_loop, args=(new_loop,), daemon=<span class="literal">True</span>)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 run_coroutine_threadsafe 调用异步函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data_sync</span>(<span class="params">x</span>):</span><br><span class="line">    future = asyncio.run_coroutine_threadsafe(fetch_data(x), new_loop)</span><br><span class="line">    <span class="keyword">return</span> future.result()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步调用异步生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">async_gen_to_sync</span>(<span class="params">agen</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            future = asyncio.run_coroutine_threadsafe(agen.__anext__(), new_loop)</span><br><span class="line">            value = future.result()</span><br><span class="line">            <span class="keyword">yield</span> value</span><br><span class="line">        <span class="keyword">except</span> concurrent.futures.TimeoutError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Timeout occurred&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> StopAsyncIteration:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    result = get_data_sync(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;fetch_data result: <span class="subst">&#123;result&#125;</span>&quot;</span>)  <span class="comment"># 输出: fetch_data result: 20</span></span><br><span class="line"></span><br><span class="line">    gen_results = sync_iter_async_gen(async_gen())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;async_gen results: <span class="subst">&#123;gen_results&#125;</span>&quot;</span>)  <span class="comment"># 输出: async_gen results: [0, 1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭事件循环</span></span><br><span class="line">    new_loop.call_soon_threadsafe(new_loop.stop)</span><br><span class="line">    t.join()</span><br><span class="line">    new_loop.close()</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fetch_data result: 20</span><br><span class="line">async_gen results: [0, 1, 2]</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ol>
<li>创建一个新的事件循环，并在独立线程中运行它。</li>
<li>使用<code>run_coroutine_threadsafe</code>同步调用异步函数<code>fetch_data</code>。</li>
<li>通过<code>sync_iter_async_gen</code>函数同步迭代异步生成器<code>async_gen</code>。</li>
<li>最后，正确关闭事件循环和相关线程。</li>
</ol>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>将异步代码转换为同步代码在Python开发中是一个常见需求，特别是在需要与现有同步系统集成时。通过理解<code>asyncio</code>的基本机制以及合理使用<code>run_coroutine_threadsafe</code>等方法，可以实现高效且可靠的异步转同步。处理异步生成器时，需要仔细管理事件循环和迭代过程，确保数据的正确获取和资源的有效利用。</p>
<p>在实践中，始终建议根据具体需求选择合适的方法，并注意避免常见的陷阱，如事件循环的冲突、线程安全问题等。通过良好的设计和充分的测试，可以有效地在异步和同步编程之间转换，实现功能强大且高效的Python应用。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Lil b</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://cmgzn.github.io/2024/11/20/coding/2024-11-20-Python-asyncio%E5%BC%82%E6%AD%A5%E8%BD%AC%E5%90%8C%E6%AD%A5/">https://cmgzn.github.io/2024/11/20/coding/2024-11-20-Python-asyncio%E5%BC%82%E6%AD%A5%E8%BD%AC%E5%90%8C%E6%AD%A5/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>STEAK</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%BC%82%E6%AD%A5-%E5%8D%8F%E7%A8%8B/"># 异步/协程</a>
                    
                        <a href="/tags/%E7%BA%BF%E7%A8%8B/"># 线程</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/11/27/coding/2024-11-27-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E9%87%8F/">多线程信号量</a>
            
            
            <a class="next" rel="next" href="/2024/11/05/pool/2024-11-05-git%20core.autocrlf%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/">git core.autocrlf配置说明</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Lil b | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>